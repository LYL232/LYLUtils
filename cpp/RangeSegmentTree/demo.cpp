/**
 * 使用实例: 值域线段树:
 * 判题网址: https://www.lydsy.com/JudgeOnline/problem.php?id=4627
 * 题目描述
 * 酷爱日料的小Z经常光顾学校东门外的回转寿司店。在这里，一盘盘寿司通过传送带依次呈现在小Z眼前。不同的寿
 * 司带给小Z的味觉感受是不一样的，我们定义小Z对每盘寿司都有一个满意度，例如小Z酷爱三文鱼，他对一盘三文
 * 鱼寿司的满意度为10；小Z觉得金枪鱼没有什么味道，他对一盘金枪鱼寿司的满意度只有5；小Z最近看了电影“美
 * 人鱼”，被里面的八爪鱼恶心到了，所以他对一盘八爪鱼刺身的满意度是-100。特别地，小Z是个著名的吃货，他
 * 吃回转寿司有一个习惯，我们称之为“狂吃不止”。具体地讲，当他吃掉传送带上的一盘寿司后，他会毫不犹豫地
 * 吃掉它后面的寿司，直到他不想再吃寿司了为止。今天，小Z再次来到了这家回转寿司店，N盘寿司将依次经过他的
 * 面前，其中，小Z对第i盘寿司的满意度为Ai。小Z可以选择从哪盘寿司开始吃，也可以选择吃到哪盘寿司为止，他
 * 想知道共有多少种不同的选择，使得他的满意度之和不低于L，且不高于R。注意，虽然这是回转寿司，但是我们不
 * 认为这是一个环上的问题，而是一条线上的问题。即，小Z能吃到的是输入序列的一个连续子序列；最后一盘转走
 * 之后，第一盘并不会再出现一次。
 * 输入
 * 第一行包含三个整数N，L和R，分别表示寿司盘数，满意度的下限和上限。
 * 第二行包含N个整数Ai，表示小Z对寿司的满意度。
 * N≤100000，|Ai|≤100000，0≤L, R≤10^9
 * 输出
 * 仅一行，包含一个整数，表示共有多少种选择可以使得小Z的满意度之和
 * 不低于L且不高于R。
 */
#include "RangeSegmentTree.h"

const int MAX_N = 100025;
const long long inf = (long long) 1e10 + 25;
int N, L, R, sum, temp;

// 前缀和加上可持久化思想：
// 令sum[x]为前缀和
// 题意即求出 1<= i < j <= N 中
// L <= sum[j] - sum[i] <= R 的选择数
// 注意什么都不选算sum为0 且只算一种，所以先要算0
// 用值域线段树来保存信息
// 值域线段树保存值域中的当前存在的数字的个数 [l, r] 表示的数据是
// 当前树中在[l, r]之间的数字的个数
// 从1到n枚举每次将前缀和插入线段树之前
// 先查询一次结果：
// L <= sum[j] - sum[i] <= R -> sum[j] - R <= sum[i] <= sum[j] - L
// 枚举j从1到N
// 线段树保存所有i<j的sum[i]
// 所以在每次插入前，查询[sum[j] - R, sum[j] - L]并累加到结果中
// 一次查询就获得了 i< j时的 L <= sum[j] - sum[i] <= R 的数量，减少了
// O(n)的时间复杂度，这个思想即可持续化思想,
// 权值线段树维护的是之前所有权值的数量
int main() {
    sum = 0;
    scanf("%d %d %d", &N, &L, &R);
    RangeSegmentTree<long long> tree(MAX_N, -1 * inf, inf);
    long long res = 0;
    for (int i = 1; i <= N; ++i) {
        scanf("%d", &temp);
        // 和为0也算一种选法
        tree.insert(sum);
        //tree.print();
        sum += temp;
        res += tree.query(sum - R, sum - L);
    }
    printf("%lld\n", res);
    return 0;
}