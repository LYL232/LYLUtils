一行N个方格，开始每个格子里都有一个整数。现在动态地提出一些问题和修改：提问的形式是求某一个特定的子区间[a,b]中所有元素的和；修改的规则是指定某一个格子x，加上或者减去一个特定的值A。现在要求你能对每个提问作出正确的回答。1≤N<100000，,提问和修改的总数m<10000条。

输入描述 Input Description
输入文件第一行为一个整数N，接下来是n行n个整数，表示格子中原来的整数。接下一个正整数m，再接下来有m行，表示m个询问，第一个整数表示询问代号，询问代号1表示增加，后面的两个数x和A表示给位置X上的数值增加A，询问代号2表示区间求和，后面两个整数表示a和b，表示要求[a,b]之间的区间和。

输出描述 Output Description
共m行，每个整数

样例输入 Sample Input
6

4 

5 

6 

2 

1 

3

4

1 3 5

2 1 4

1 1 9

2 2 6

样例输出 Sample Output
22

22

#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
long long tree[maxn*4],a[maxn];
long long quiry(int ln,int rn,int index,int l,int r)
{
    if(l<=ln&&r>=rn)
        return tree[index];
    int mid=(rn+ln)>>1;
    if(r<=mid)
        return quiry(ln,mid,index<<1,l,r);
    if(l>mid)
        return quiry(mid+1,rn,index<<1|1,l,r);
    return quiry(ln,mid,index<<1,l,mid)+quiry(mid+1,rn,index<<1|1,mid+1,r);
}
void update(int ln,int rn,int index,int x,int change)
{
    tree[index]+=change;
    if(ln>=rn||x<ln||x>rn)
        return;
    int mid=(rn+ln)>>1;
    if(x<=mid)
        update(ln,mid,index<<1,x,change);
    else
        update(mid+1,rn,index<<1|1,x,change);
}
void build(int ln,int rn,int x)
{
    if(ln>=rn)
    {
        tree[x]=a[ln];
        return ;
    }
    int mid=(ln+rn)>>1;
    build(ln,mid,x<<1);
    build(mid+1,rn,x<<1|1);
    tree[x]=tree[x<<1]+tree[x<<1|1];
}
int n,m;
int main()
{
    int x,y,z;
    memset(tree,0,4*maxn*sizeof(long long));
    memset(a,0,maxn*sizeof(int));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    build(1,maxn,1);
    scanf("%d",&m);
    for(int i=0;i<m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        if(x==1)
            update(1,maxn,1,y,z);
        else
            printf("%lld\n",quiry(1,maxn,1,y,z));
    }
    return 0;
}
