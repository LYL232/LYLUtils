题目描述
如题，已知一个数列，你需要进行下面两种操作：

1.将某区间每一个数加上x

2.求出某区间每一个数的和

输入输出格式
输入格式：
第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。

第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。

接下来M行每行包含3或4个整数，表示一个操作，具体如下：

操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k

操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和

输出格式：
输出包含若干行整数，即为所有操作2的结果。

输入输出样例
输入样例#1： 
5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4
输出样例#1： 
11
8
20


#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e5+10;
int n,m,op,l,r;
long long a[MAXN],k;
struct NODE
{
    int l,r,mid;
    long long data,lazy;
}tree[MAXN<<2];
void pushUp(int i)
{
    tree[i].data=tree[i<<1].data+tree[i<<1|1].data;
}
void pushDown(int i)
{
    //printf("pushDown(%d,%lld,%lld)\n",i,tree[i].data,tree[i].lazy);
    int ls=i<<1,rs=i<<1|1;
    tree[ls].lazy+=tree[i].lazy;
    tree[rs].lazy+=tree[i].lazy;
    tree[ls].data+=(long long)(tree[ls].r-tree[ls].l+1)*tree[i].lazy;
    tree[rs].data+=(long long)(tree[rs].r-tree[rs].l+1)*tree[i].lazy;
    tree[i].lazy=0;
}
void build(int l,int r,int i)
{
    tree[i].l=l;tree[i].r=r;
    int mid=(l+r)>>1;
    tree[i].mid=mid;
    tree[i].lazy=0;
    if(l>=r)
    {
        tree[i].data=a[l];
        return;
    }
    build(l,mid,i<<1);
    build(mid+1,r,(i<<1)+1);
    pushUp(i);
}
void update(int l,int r,int i,long long x)
{
    //printf("update(%d,%d,%d,%lld)[%d,%d]\n",l,r,i,x,tree[i].l,tree[i].r);
    if(l<=tree[i].l&&tree[i].r<=r)
    {
        //printf("lazy=%lld,x=%lld\n",tree[i].lazy,x);
        tree[i].data+=(long long)(tree[i].r-tree[i].l+1)*x;
        tree[i].lazy+=x;
        return ;
    }
    pushDown(i);
    if(l<=tree[i].mid)update(l,r,i<<1,x);
    if(r>tree[i].mid)update(l,r,i<<1|1,x);
    pushUp(i);
}
long long query(int l,int r,int i)
{
    if(l<=tree[i].l&&tree[i].r<=r)return tree[i].data;
    pushDown(i);
    long long res=0;
    if(l<=tree[i].mid)res+=query(l,r,i<<1);
    if(r>tree[i].mid)res+=query(l,r,i<<1|1);
    return res;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%lld",a+i);
    build(1,n,1);
    while(m--)
    {
        scanf("%d",&op);
        if(op==1)
        {
            scanf("%d%d%lld",&l,&r,&k);
            update(l,r,1,k);
        }
        else
        {
            scanf("%d%d",&l,&r);
            printf("%lld\n",query(l,r,1));
        }
    }
    return 0;
}
